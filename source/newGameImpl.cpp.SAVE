#include <fmt/format.h>

#include <iostream>
#include <variant>

namespace helper {
  template <class... Ts> struct overload : Ts... {
    using Ts::operator()...;
  };

  template <class... Ts> overload(Ts...) -> overload<Ts...>;  // no need in C++20, MSVC?
}  // namespace helper

namespace state {
  struct PlayerAlive {
    unsigned int health_{0};
    unsigned int remainingLives_{0};
  };

  struct PlayerDead {
    unsigned int remainingLives_{0};
  };

  struct GameOver {};
}  // namespace state

/*
[[[STATE MACHINE : DEFINED STATE]]]
*/
using HealthState = std::variant<state::PlayerAlive, state::PlayerDead, state::GameOver>;

/*
[[[STATE MACHINE :DEFINED EVENT]]]
*/
namespace event {
  struct HitByMonster {
    unsigned int forcePoints_{0};
  };

  struct Heal {
    unsigned int points_{0};
  };

  struct Restart {
    unsigned int startHealth_{0};
  };
}  // namespace event


/*
[[[STATE MACHINE ON-EVENT-PROCESS]]]
*/
using PossibleEvent = std::variant<event::HitByMonster, event::Heal, event::Restart>;


HealthState onEvent(const state::PlayerAlive& alive, const event::HitByMonster& monster) {
  std::cout << fmt::format("PlayerAlive -> HitByMonster force {}\n", monster.forcePoints_);
  if (alive.health_ > monster.forcePoints_) {
    return state::PlayerAlive{alive.health_ - monster.forcePoints_, alive.remainingLives_};
  }

  if (alive.remainingLives_ > 0) return state::PlayerDead{alive.remainingLives_ - 1};

  return state::GameOver{};
}

HealthState onEvent(const state::PlayerAlive& alive, const event::Heal& healingBonus) {
  std::cout << fmt::format("PlayerAlive -> Heal points {}\n", healingBonus.points_);

  return state::PlayerAlive{alive.health_ + healingBonus.points_, alive.remainingLives_};
  ;
}

HealthState onEvent(const state::PlayerDead& dead, const event::Restart& restart) {
  std::cout << fmt::format("PlayerDead -> restart\n");

  return state::PlayerAlive{restart.startHealth_, dead.remainingLives_};
}

HealthState onEvent(const state::GameOver& over, const event::Restart& restart) {
  std::cout << fmt::format("GameOver -> restart\n");

  std::cout << "Game Over, please restart the whole game!\n";

  return over;
}

HealthState onEvent(const auto&, const auto&) {
  throw std::logic_error{"Unsupported state transition"};
}

/*
[[[STATE MACHINE]]]
*/
class GameStateMachine {
public:
  void startGame(unsigned int health, unsigned int lives) {
    state_ = state::PlayerAlive{health, lives};
  }

  void processEvent(const PossibleEvent& event) {
    state_ = std::visit(
        helper::overload{[](const auto& state, const auto& evt) { return onEvent(state, evt); }},
        state_, event);
  }

#if 1
  void reportCurrentState() {
    std::visit(helper::overload{
                   [](const state::PlayerAlive& alive) {
                     std::cout << fmt::format("PlayerAlive {} remaining lives {}\n", alive.health_,
                                              alive.remainingLives_);
                   },
                   [](const state::PlayerDead& dead) {
                     std::cout << fmt::format("PlayerDead, remaining lives {}\n",
                                              dead.remainingLives_);
                   },
                   [](const state::GameOver& over) { std::cout << fmt::format("GameOver\n"); }},
               state_);
  }
#endif

private:
  HealthState state_;
};

/*
[[[TEST_EVENT]]]
*/
void GameHealthFSMTest() {
  std::cout << fmt::format("sizeof(HealthState):   {}\n", sizeof(HealthState));
  std::cout << fmt::format("sizeof(PossibleEvent): {}\n", sizeof(PossibleEvent));

  GameStateMachine game;
  game.startGame(100, 1);

  try {
    game.processEvent(event::HitByMonster{30});
#if 1
    game.reportCurrentState();
    game.processEvent(event::HitByMonster{30});
    game.reportCurrentState();

    game.processEvent(event::Heal{10});
    game.reportCurrentState();

    game.processEvent(event::HitByMonster{30});
    game.reportCurrentState();
    game.processEvent(event::HitByMonster{30});
    game.reportCurrentState();
    game.processEvent(event::Restart{100});
    game.reportCurrentState();
    game.processEvent(event::HitByMonster{60});
    game.reportCurrentState();
    game.processEvent(event::HitByMonster{50});
    game.reportCurrentState();
    game.processEvent(event::Restart{110});
    game.reportCurrentState();
#endif

  } catch (std::exception& ex) {
    std::cout << "Exception! " << ex.what() << '\n';
  }
}
